---
title: "Estimating the effect of AMU on colistin resistance in chicken farms"
csl: the-american-naturalist.csl
output:
  html_document:
    theme: cerulean
    toc: yes
  pdf_document:
    toc: yes
<!-- bibliography: references.bib -->
---

<!--
IMAGES:
Insert them with: ![alt text](image.png)
You can also resize them if needed: convert image.png -resize 50% image.png
If you want to center the image, go through HTML code:
<div style="text-align:center"><img src ="image.png"/></div>

REFERENCES:
For references: Put all the bibTeX references in the file "references.bib"
in the current folder and cite the references as @key or [@key] in the text.
Uncomment the bibliography field in the above header and put a "References"
title wherever you want to display the reference list.
-->

<style type="text/css">
.main-container {
  max-width: 1370px;
  margin-left: auto;
  margin-right: auto;
}
</style>

```{r general_options, include = FALSE}
knitr::knit_hooks$set(
  margin = function(before, options, envir) {
    if (before) par(mgp = c(1.5, .5, 0), bty = "n", plt = c(.105, .97, .13, .97))
    else NULL
  },
  prompt = function(before, options, envir) {
    options(prompt = if (options$engine %in% c("sh", "bash")) "$ " else "> ")
  })

knitr::opts_chunk$set(margin = TRUE, prompt = TRUE, comment = "",
                      collapse = TRUE, cache = FALSE, autodep = TRUE,
                      dev.args = list(pointsize = 11), fig.height = 3.5,
                      fig.width = 4.24725, fig.retina = 2, fig.align = "center")

options(width = 137)
```

The objective is to build a dynamic model allowing to estimate the effect of antimicrobial usage (AMU), particularly colistin, on colistin resistance in ViParc chicken farms. Available data is:

* Data on ViParc farms, including AMU and sampling dates: [ViParc data overview](https://rpubs.com/choisy/viparc_data).
* During each production cycle, 3 (or less) pooled chicken faeces samples are collected: at the beginning, in the middle and at the end of the cycle. Each pooled sample is believed to represent the faeces of around 50 individual chickens at the sampling day (no matters the farm size). The proportion of colonies of each  sample that are colistin resistant is determined.

We first clean work environment and load needed packages.

```{r}
rm(list=ls(all=TRUE))

# install.packages("deSolve", "bbmle", "ggplot2", "adaptivetau")
library(deSolve)
library(bbmle)
library(ggplot2)
library(adaptivetau)
```

## Data

We load data:

* `viparc_data_quali` and `viparc_data_quanti`: Includes production cycles, AMU (resp. qualitative and quantitative), sampling dates in ViParc farms.
* `count_data`: Proportion of colistin resistant colonies in some of the pooled samples. For now, `count_data` only includes the proportion of resistance for the initial samples in some of the farms.

```{r, cache=T}
# viparc_data_quali = read.csv("https://raw.githubusercontent.com/viparc/colistin_resistance/master/data/viparc_qualitative.csv")
# viparc_data_quanti = read.csv("https://raw.githubusercontent.com/viparc/colistin_resistance/master/data/viparc_quantitative.csv")

viparc_data_quali = read.csv("C:/Users/Jonathan/Desktop/Programmes/colistin_resistance/viparc_qualitative.csv")
viparc_data_quanti = read.csv("C:/Users/Jonathan/Desktop/Programmes/colistin_resistance/viparc_quantitative.csv")

# count_data = read.csv("https://raw.githubusercontent.com/viparc/colistin_resistance/master/data/ColRdata_210519.csv", sep=";")
count_data = read.csv("C:/Users/Jonathan/Desktop/Programmes/colistin_resistance/ColRdata_210519.csv", sep=";", skip=1)[,1:7]

```

### Choice of the cycles included in the analysis

Some farms from the ViParc study were already chosen for resistant colonies counting. However, it can be interesting to test (i) a change of the farms analyzed, and (ii) a scenario where the number of samples is higher than in the actual study.

Several cases are therefore possible. In all cases, AMU data is actually observed in the study and not simulated. We create a matrix containing binary information on AMU (antimicrobial used / not used) for each week (columns) of the production cycle and for each farm (rows): `ab_expo`.

* Case 1 (`case_amu = 1`). We use real counting measures for selected farms, and real cycle lengths. As, for now, only initial samples are available, we simulate the counts for the other samples. In this case, `n_samp` is set to 3 (real value in the study). We can focus on one (e.g. colistin use) or several antibiotics for use data.

* In cases 2 and 3, the number of cycles included is set to `n_cyc = 30`. We simulate all counting measures. We can choose the number of samples `n_samp` collected in farms. We can choose the length of production cycles `n_weeks` (is similar across all farms). The sampling dates are calculated depending on `n_weeks` and `n_samp`.

  * Case 2 (`case_amu = 2`). We are interested in colistin usage only. The cycles included are the 10 first farms using colistin on week 8 + 10 farms using no colistin.
  
  * Case 3 (`case_amu = 3`). We are interested in global AMU. The farms analysed are the 20 first farms with a production cycle of `n_weeks` weeks or more.

To select the case chosen, and the number of samples and production length if the case if not 1:
```{r}
case_amu = 1

# Necessary if (and only if) case_amu != 0:
n_samp = 3 # Maximum number of samples during a cycle
n_weeks = 16 # Maximum length of production cycle among those included
```

If case 1 (`case_amu=1`) is chosen, we then specify the antibiotics in which we want to include AMU:

```{r}
ab_inc_amu = "colistin_use"
# ab_inc_amu = colnames(viparc_data_quali)[10:54]
```

We define `n_cyc` and `obs_init_true` (proportion of resistant colonies in the initial samples) depending on the case chosen:

```{r}
if (case_amu == 1){
  n_samp = 3
  n_cyc = nrow(count_data)
  
  obs_init_true = 0.001 + count_data$Start /100
  
  obs = matrix(NA, n_cyc, n_samp)
  
  obs[,1] = obs_init_true
  obs[,c(2,3)] = 0.001 + cbind(count_data$Mid, count_data$End)/100
  names(obs_init_true) = rownames(obs) = count_data$FarmID
}else{
  n_cyc = 30 # Number of cycles (farms) included
  
  obs_init_true = runif(n_cyc,0,1)
  
  obs = matrix(NA, n_cyc, n_samp)
  obs[,1] = obs_init_true
  
  weeks_samp = matrix(ceiling(seq(1, n_weeks, length.out = n_samp)), n_cyc, n_samp, byrow=T)
  init_flock_size = rep(200, n_cyc)
}
```

We calculate `ab_expo`, `weeks_samp` (week of samplings for each cycle included), and `init_flock_size` (initial flock size for each cycle included):

```{r}
if (case_amu == 1){
  
  ab_expo = matrix(NA, n_cyc, max(viparc_data_quali$week))
  ab_expo_quanti = matrix(NA, n_cyc, max(viparc_data_quali$week))
  weeks_samp = matrix(NA, n_cyc, n_samp)
  init_flock_size = rep(NA, n_cyc)
  rownames(ab_expo) = rownames(weeks_samp) = names(init_flock_size) = count_data$ID
  
  for(i in 1:n_cyc){
    farm_i = as.character(count_data$FarmID[i])
    flockseq_i = as.character(count_data$Flockseq[i])
    
    if(!(any(viparc_data_quali$completed[which((viparc_data_quali$farm == farm_i)&(viparc_data_quali$flock == flockseq_i))]) == T)){
      print(paste0("For farm ",farm_i,", flock sequence ",flockseq_i,", the production cycle was not completed"))
    }
    
    if(length(ab_inc_amu) > 1){
      
      weeks_use = viparc_data_quali$week[which((viparc_data_quali$farm == farm_i)&(viparc_data_quali$flock == flockseq_i)&(rowSums(viparc_data_quali[,ab_inc_amu], na.rm=T) !=0))]
      weeks_no_use = viparc_data_quali$week[which((viparc_data_quali$farm == farm_i)&(viparc_data_quali$flock == flockseq_i)&(rowSums(viparc_data_quali[,ab_inc_amu], na.rm=T) ==0))]
      
    }else if(length(ab_inc_amu) == 1){
      
      weeks_use = viparc_data_quali$week[which((viparc_data_quali$farm == farm_i)&(viparc_data_quali$flock == flockseq_i)&(viparc_data_quali[,ab_inc_amu] == T))]
      weeks_no_use = viparc_data_quali$week[which((viparc_data_quali$farm == farm_i)&(viparc_data_quali$flock == flockseq_i)&(viparc_data_quali[,ab_inc_amu] == F))]

    }
    
    ab_expo[i, weeks_use] = 1
    ab_expo[i, weeks_no_use] = 0
    
    for(wk in weeks_use){
      ab_expo_quanti[i, wk] = max(viparc_data_quanti[which((viparc_data_quanti$farm == farm_i)&(viparc_data_quanti$flock == flockseq_i)&(viparc_data_quanti$week == wk)), which(colnames(viparc_data_quali) %in% ab_inc_amu)])
    }
    for(wk in weeks_no_use){
      ab_expo_quanti[i, wk] = 0
    }
    
    weeks_samp[i,] = c(viparc_data_quali$week[which((viparc_data_quali$farm == farm_i)&(viparc_data_quali$flock == flockseq_i)&(viparc_data_quali$sampling == T))], rep(NA, n_samp))[1:n_samp]
    
    init_flock_size[i] = viparc_data_quali$nb_chicken[which((viparc_data_quali$farm == farm_i)&(viparc_data_quali$flock == flockseq_i)&(viparc_data_quali$week == 1))]
  }
  
  weeks_to_keep = which(colSums(!is.na(ab_expo)) != 0)
  ab_expo = ab_expo[,weeks_to_keep]
  ab_expo_quanti = ab_expo_quanti[,weeks_to_keep]
  n_weeks = max(weeks_to_keep)
  
  rm(i, weeks_use, weeks_no_use, farm_i, flockseq_i, weeks_to_keep)
  print("Case 1 chosen.")

}else if (case_amu == 2){

  f_using_col_before_week_9 = viparc_data_quali[which(viparc_data_quali$week %in% c(8) & viparc_data_quali$colistin == T), c("farm","flock")]
  f_using_col_before_week_9 = f_using_col_before_week_9[which(duplicated(f_using_col_before_week_9)==F),]
  if (nrow(f_using_col_before_week_9) <15){print("Number of adequate farms is less than 15")}

  ab_expo = matrix(0, 15, n_weeks)
  for(i in 1:15){
    farm_i = f_using_col_before_week_9$farm[i]
    flockseq_i = f_using_col_before_week_9$flock[i]
    weeks_use = viparc_data_quali$week[which((viparc_data_quali$farm == farm_i)&(viparc_data_quali$flock == flockseq_i)&(viparc_data_quali$colistin == T))]
    ab_expo[i, weeks_use[which(weeks_use <= n_weeks)]] = 1
  }
  ab_expo = rbind(ab_expo, matrix(0,15,n_weeks))
  rm(i, f_using_col_before_week_9, weeks_use, farm_i, flockseq_i)
  print("Case 2 chosen.")

}else if (case_amu == 3){

  ab_expo = matrix(0, n_cyc, n_weeks)
  iter_farm = 0
  for (i in 1:n_cyc){
    weeks_cycle = c()
    while(!(n_weeks %in% weeks_cycle)){
      iter_farm = iter_farm + 1
      if(iter_farm == (length(names(table(factor(viparc_data_quali$farm)))) +1)){print("No more farm respecting the criteria")}

      farm_i = names(table(factor(viparc_data_quali$farm)))[iter_farm]
      weeks_cycle = viparc_data_quali$week[which((viparc_data_quali$farm==farm_i)&(viparc_data_quali$flock==1))]
    }

    weeks_use = c()
    for (w in 1:n_weeks){
      weeks_use = c(weeks_use, as.numeric(sum(as.numeric(viparc_data_quali[which((viparc_data_quali$farm == farm_i)&(viparc_data_quali$flock == 1)&(viparc_data_quali$week == w)),(10:53)])) != 0))
    }
    ab_expo[i,] = weeks_use
  }
  rm(i, w, iter_farm, weeks_use, weeks_cycle, farm_i)
  print("Case 3 chosen.")

}else{
  print("This case doesn't exist.")
}
```

We plot the AMU and sampling dates for the `n_cyc` farms. This allows to visually assess if AMU occurs shortly before sampling.

```{r}
plot(x=c(0,0.1), y=c(0,0), xlim=c(0,ncol(ab_expo)), ylim=c(0,n_cyc+10), type="l", xlab="Weeks", ylab="Farms")
for (i in 1:n_cyc){
  for (j in 1:ncol(ab_expo)){
    
    if ((!(is.na(ab_expo[i,j]))) & (ab_expo[i,j] == 1)){
      rect(xleft = j-0.5, xright = j+0.5, ybottom = i-0.5, ytop = i+0.5, col = "blue", border="blue")
    }else if ((!(is.na(ab_expo[i,j]))) & (ab_expo[i,j] == 0)){
      rect(xleft = j-0.5, xright = j+0.5, ybottom = i-0.5, ytop = i+0.5, col = "light blue", border="light blue")
    }
    
    if (any(weeks_samp[i,] == j, na.rm=T)){
      rect(xleft = j-0.1, xright = j+0.1, ybottom = i-0.5, ytop = i+0.5, col = "red", border="red")
    }
  }
}
rm(i,j)
legend(x=1, y=n_cyc+10, legend=c("AMU", "No AMU", "Samplings"), fill=c("blue", "light blue", "red"), cex = 0.8, ncol=3)

```

### Simulated colistin resistance data

As colistin resistance data is not fully available yet, we simulate colistin resistance data. Sampling dates were determined above.

We present in the following different models possible to analyze this data.

### Simple analysis

```{r}
tab = data.frame("end_start" = obs[1:11,3]-obs[1:11,1], "mid_start" = obs[1:11,2]-obs[1:11,1], "end_mid" = obs[1:11,3]-obs[1:11,2], "abs_amu_tot" = rowSums(ab_expo[1:11,], na.rm=T))

tab$prop_expo_mid_start = rep(NA, nrow(tab))
tab$prop_expo_end_start = rep(NA, nrow(tab))
tab$prop_expo_end_mid = rep(NA, nrow(tab))
for (i in 1:nrow(tab)){
  
  if(is.finite(weeks_samp[i,2])){
    tab$prop_expo_mid_start[i] = sum(ab_expo[i,1:weeks_samp[i,2]])/sum(is.finite(ab_expo[i,1:weeks_samp[i,2]]))
  } 
  
  if(is.finite(weeks_samp[i,3])){
    tab$prop_expo_end_start[i] = sum(ab_expo[i,1:weeks_samp[i,3]])/sum(is.finite(ab_expo[i,1:weeks_samp[i,3]]))
  }
  
  if((is.finite(weeks_samp[i,3])) & (is.finite(weeks_samp[i,2]))){
    tab$prop_expo_end_mid[i] = sum(ab_expo[i,(weeks_samp[i,2]+1):weeks_samp[i,3]])/sum(is.finite(ab_expo[i,(weeks_samp[i,2]+1):weeks_samp[i,3]]))
  }
}

summary(lm(data=tab, mid_start ~ prop_expo_mid_start))
summary(lm(data=tab, end_start ~ prop_expo_end_start))
summary(lm(data=tab, end_mid ~ prop_expo_end_mid))

rm(i)
```

## Model 1: Global resistance on farm (deterministic)

In this simple model, we study the global microbiote on farm, and consider the variable $R(t)$ representing the proportion of bacteria presenting a colistin resistance phenotype in a farm f. As sums of proportions of sensitive and resistant bacteria is 1, we only focus on the proportion of resistant bacteria.

For a given farm f, we define the model as follows:
$$ \frac{dR}{dt} = 1-(1 + A.\alpha ^ {E(t)}).R(t) $$
where $E(t)$ is AMU (0 or 1) in farm i, at week t.

$A$ and $\alpha$ must be strictly positive. $\alpha$ represents the effect of AMU on colistin resistance dynamics:

* If $\alpha = 1$, AMU has no effect on colistin resistance.
* If $\alpha < 1$, AMU increases colistin resistance on farm.
* If $\alpha > 1$, AMU decreases colistin resistance on farm.

The model is defined:

```{r}
eq_mod=function(t, R, param){
  alpha = param[[1]]
  A = param[[2]]
  ab_expo_farm = param[[3]]
  
  dR = 1 - (1 + A * (alpha ^ ab_expo_farm[t])) * R
  
  return(list(dR))
}

eq_mod=function(t, R, param){
  alpha = param[[1]]
  A = param[[2]]
  ab_expo_farm = param[[3]]
  
  dR = 1 - (1 + A * (alpha ^ ab_expo_farm[t])) * R
  
  return(list(dR))
}

```

### Simulated "observed" colistin resistance data (for the `case_amu` $\neq$ 1)

We do have the initial proportion of resistance in the farms (real or simulated depending on what was chosen). We then simulate resistance data for the 2 others samples in each farm, using Model 1, adding some stochastic noise for these "observed" samples. Parameters for the simulated data are `alpha_true` and `A_true`, defined below.

It is possible to plot the simulated "observed" data for each farm, by setting `plot_sim_data = T`. In this case, dotted lines represent the sampling dates. Black bars represent AMU dates in farms.

```{r}
if(case_amu != 1){
  plot_sim_data = F
}
```

```{r}
if(case_amu != 1){
  alpha_true = 0.2
  A_true = 5
}
```

Data simulation:

```{r}
if(case_amu != 1){

  for(farm in 1:n_cyc){
    n_weeks_farm = sum(!(is.na(ab_expo[farm,])))
    n_samp_farm = sum(!(is.na(weeks_samp[farm,])))
    if(n_samp_farm < 2){print(paste0("CAUTION: For farm ", farm,", the number of samples collected is strictly less than 2"))}
  
    simul_det = ode(obs_init_true[farm], 1:n_weeks_farm, eq_mod, list(alpha_true, A_true, ab_expo[farm,]))[,2]
    simul_stoch = rnorm(n=n_weeks_farm, mean=simul_det, sd=0.02)
  
    obs[farm,(2:n_samp_farm)] = simul_stoch[weeks_samp[farm,(2:n_samp_farm)]]
  
    if(plot_sim_data){
      plot(simul_stoch, main=paste0("Simulated data for farm ", farm), ylim=c(0,1), type="l", xlab="Time (weeks)", ylab="Proportion of resistant colonies R(t)")
      
      for (i in 1:n_weeks_farm){
        if (ab_expo[farm,i] == 1){
          rect(xleft = i-0.5, xright = i+0.5, ybottom = 1, ytop = 1.1, col = "black")
        }
      }
  
      for(i in weeks_samp[farm,(1:n_samp_farm)]){
        lines(x=c(i,i), y=c(-1,2), lt="dashed")
      }
      rm(i)
    }
  }
  rm(farm, n_weeks_farm, n_samp_farm, simul_det, simul_stoch)
  
}
```

### Parameters estimation

We first define functions with model's parameters as inputs, and as ouput:

* run1: Squared residuals sum
* run2: Likelihood with residuals drawn in a Gaussian or Beta
```{r}
run1 = function(param){
  alpha = param[1]
  A = param[2]

  pred_sampl_dates = matrix(NA, n_cyc, n_samp)
  
  for (farm in 1:n_cyc){
    n_weeks_farm = sum(!(is.na(ab_expo[farm,])))
    n_samp_farm = sum(!(is.na(weeks_samp[farm,])))
    if(n_samp_farm < 2){print(paste0("CAUTION: For farm ", farm,", the number of samples collected is strictly less than 2"))}

    pred_farm = ode(obs_init_true[farm], 1:n_weeks_farm, eq_mod, list(alpha, A, ab_expo[farm,]))[,2]
    
    pred_sampl_dates[farm, (1:n_samp_farm)] = pred_farm[weeks_samp[farm,(1:n_samp_farm)]]
  }
  rm(farm, pred_farm, n_weeks_farm, n_samp_farm)

  to_min = sum((pred_sampl_dates-obs)^2, na.rm=T)

  return(to_min)
  # return(list(to_min, pred_sampl_dates))
}

run2 = function(alpha, A, k){

  pred_sampl_dates = matrix(NA, n_cyc, n_samp)
  
  for (farm in 1:n_cyc){
    n_weeks_farm = sum(!(is.na(ab_expo[farm,])))
    n_samp_farm = sum(!(is.na(weeks_samp[farm,])))
    if(n_samp_farm < 2){print(paste0("CAUTION: For farm ", farm,", the number of samples collected is strictly less than 2"))}

    pred_farm = ode(obs_init_true[farm], 1:n_weeks_farm, eq_mod, list(alpha, A, ab_expo[farm,]))[,2]
    
    pred_sampl_dates[farm, (1:n_samp_farm)] = pred_farm[weeks_samp[farm,(1:n_samp_farm)]]
  }
  rm(farm, pred_farm, n_weeks_farm, n_samp_farm)

  # return(-sum(dnorm(x=obs, mean=pred_sampl_dates, sd=k, log=T)))
  return(-sum(dbeta(x=obs, shape1=k, shape2=k*(1.00001-pred_sampl_dates)/(pred_sampl_dates+0.00001), log=T), na.rm=T))
}
```

These functions allow us to perform the parameters estimation.

#### Using "optim" function for point estimates

```{r}
# fit = optim(par=c(1,1), fn=run1)
# print(fit$par)
```

#### Using "bbmle" package for point estimates, confidence intervals and likelihood profiles

```{r}
fit_mle2 = mle2(minuslogl = run2, start = list(alpha=1, A=1, k=1), lower=c(alpha=10^-5, A=10^-5, k=10^-5))
fit_coef = coef(fit_mle2)
print(fit_coef)
# prof = profile(fit_mle2)
# plot(prof)
# conf = confint(fit_mle2)
# print(conf)
```

### Plot of model predictions

```{r echo=F}
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {
  # Multiple plot function
  # Source: http://www.cookbook-r.com/Graphs/Multiple_graphs_on_one_page_(ggplot2)
  # 
  # ggplot objects can be passed in ..., or to plotlist (as a list of ggplot objects)
  # - cols:   Number of columns in layout
  # - layout: A matrix specifying the layout. If present, 'cols' is ignored.
  #
  # If the layout is something like matrix(c(1,2,3,3), nrow=2, byrow=TRUE),
  # then plot 1 will go in the upper left, 2 will go in the upper right, and
  # 3 will go all the way across the bottom.

  library(grid)

  # Make a list from the ... arguments and plotlist
  plots <- c(list(...), plotlist)

  numPlots = length(plots)

  # If layout is NULL, then use 'cols' to determine layout
  if (is.null(layout)) {
    # Make the panel
    # ncol: Number of columns of plots
    # nrow: Number of rows needed, calculated from # of cols
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),
                     ncol = cols, nrow = ceiling(numPlots/cols))
  }

  if (numPlots==1) {
    print(plots[[1]])

  } else {
    # Set up the page
    grid.newpage()
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))

    # Make each plot, in the correct location
    for (i in 1:numPlots) {
      # Get the i,j matrix positions of the regions that contain this subplot
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))

      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
                                      layout.pos.col = matchidx$col))
    }
  }
}
```

We plot observations (red dots) and model predictions (black line and CI) for `farms_plot` farms.

AMU is represented as blue bars. We can plot the qualitative use (yes/no each week), or the quantitative use (what amount per kg of chicken each week). In the latter case, the quantity in case several antibiotics are used at the same time must be clearly defined in `ab_expo_quanti`.

```{r}
farms_plot = 1:11
amu_quanti = F
```

```{r warning=F}
pred_vs_obs = data.frame(farm=rep(NA, n_cyc*n_weeks), week=rep(NA, n_cyc*n_weeks), obs=rep(NA, n_cyc*n_weeks), pred_val=rep(NA, n_cyc*n_weeks), pred_inf=rep(NA, n_cyc*n_weeks), pred_sup=rep(NA, n_cyc*n_weeks), exp_ab=rep(NA, n_cyc*n_weeks))

pred_vs_obs$farm = as.vector(matrix(rep(seq(1,n_cyc),n_weeks), n_weeks, n_cyc, byrow=T))
pred_vs_obs$week = rep(seq(1,n_weeks),n_cyc)

for (f in 1:n_cyc){
  n_weeks_farm = sum(!(is.na(ab_expo[f,])))
  n_samp_farm = sum(!(is.na(weeks_samp[f,])))
  if(n_samp_farm < 2){print(paste0("CAUTION: For farm ", f,", the number of samples collected is strictly less than 2"))}

  pred_vs_obs$obs[which((pred_vs_obs$farm==f) & (pred_vs_obs$week %in% weeks_samp[f,(1:n_samp_farm)]))] = obs[f, (1:n_samp_farm)]

  predict_farm = ode(obs[f, 1], 1:n_weeks_farm, eq_mod, list(fit_coef[1], fit_coef[2], ab_expo[f,]))[,2]
  
  pred_vs_obs$pred_val[which((pred_vs_obs$farm==f) & (pred_vs_obs$week %in%(1:n_weeks_farm)))] = predict_farm

  # Si ecarts suivent une loi beta:
  pred_vs_obs$pred_inf[which((pred_vs_obs$farm==f) & (pred_vs_obs$week %in%(1:n_weeks_farm)))] = qbeta(p=0.025, shape1=fit_coef[3], shape2=fit_coef[3]*(1.00001-predict_farm)/(predict_farm+0.00001))
  
  pred_vs_obs$pred_sup[which((pred_vs_obs$farm==f) & (pred_vs_obs$week %in%(1:n_weeks_farm)))] = qbeta(p=0.975, shape1=fit_coef[3], shape2=fit_coef[3]*(1.00001-predict_farm)/(predict_farm+0.00001))

  if(amu_quanti){
    pred_vs_obs$exp_ab[which(pred_vs_obs$farm == f)] = ab_expo_quanti[f,]
  }else{
    pred_vs_obs$exp_ab[which(pred_vs_obs$farm == f)] = ab_expo[f,]
  }
  
  rm(predict_farm)
}

pred_vs_obs$exp_ab[pred_vs_obs$exp_ab == 0] = NA
if(amu_quanti){
  pred_vs_obs$exp_ab[which(pred_vs_obs$exp_ab > quantile(pred_vs_obs$exp_ab, probs=0.9, na.rm=T))] = quantile(pred_vs_obs$exp_ab, probs=0.9, na.rm=T)
}

rm(f, n_weeks_farm, n_samp_farm)

pl = list()
iter_list = 0
for (far in farms_plot){
  iter_list = iter_list + 1
  p = ggplot(data=pred_vs_obs[which(pred_vs_obs$farm==far),], aes(x=week)) + xlab("Time (weeks)") + ylab("Prop. of resistant colonies R(t)") + ggtitle(paste0("Farm ",far))
  p = p + geom_ribbon(aes(ymin=pred_inf, ymax=pred_sup), color="black", alpha=1/4, fill="#E69F00")
  p = p + geom_line(aes(y=pred_val), col="black", size=1)
  p = p + geom_point(aes(y = obs), size = 3, shape = 21,  fill = "red", color = "black")
  
  if(amu_quanti){
    p = p + ylim(0,1+max(pred_vs_obs$exp_ab, na.rm=T))
    p = p + geom_rect(aes(xmin=week*(exp_ab>0)-0.5, xmax=week*(exp_ab>0)+0.5, ymin=0.97, ymax=1+exp_ab), fill="blue", col=NA)
  }else{
    p = p + ylim(0,1)
    p = p + geom_rect(aes(xmin=week*exp_ab-0.5, xmax=week*exp_ab+0.5, ymin=0.97, ymax=1), fill="blue", col=NA)
  }
  
  pl[[iter_list]] = p
}
multiplot(plotlist=pl, cols=3)
rm(far, iter_list, p, pl)
```


## Model 2: Metapopulation of chicken intestinal microbiotes

In this model, we study the interaction of individual chicken microbiotes with farms environment. In a given farm f, we consider the variable $R_i(t)$ representing the proportion of bacteria presenting a colistin resistance phenotype in a chicken i. As the sum of proportions of sensitive and resistant bacteria is 1, we only focus on the proportion of resistant bacteria.

The proportion of resistance in a given chicken ($R_i(t)$) depends on AMU, and on the mean proportion of resistance in the rest of the flock ($\overline{R_j(t)}$), because transmission occurs between chickens.

For a given farm f housing $N_{chi}$ (`N_chi`) chickens, we define the model as follows:

$$ \forall i \in [1;N_{chi}],	\frac{dR_i}{dt} = 1-(1 + A.\alpha ^ {E(t)}).R_i(t) + \beta.(\overline{R_j(t)}-R_i(t)) $$

where $E(t)$ is AMU (0 or 1) in farm f, at week t.

$A$, $\beta$ and $\alpha$ must be strictly positive.

$\beta$ represents the transmission of resistant bacteria between chicken guts.

$\alpha$ represents the effect of AMU on colistin resistance dynamics:

* If $\alpha = 1$, AMU has no effect on colistin resistance.
* If $\alpha < 1$, AMU increases colistin resistance in chicken guts.
* If $\alpha > 1$, AMU decreases colistin resistance in chicken guts.

It is possible to add a death process for chickens (as the mortality on farm is high).

We define the model:

```{r}
eq_mod_2 = function(t, R, param){
  N_chi_farm = param[[1]]
  
  alpha = param[[2]]
  A = param[[3]]
  beta = param[[4]]
  ab_expo_farm = param[[5]]
  
  dR = rep(NA, N_chi_farm)
  
  for(i in 1:N_chi_farm){
    dR[i] = 1 - (1 + A * (alpha ^ ab_expo_farm[t])) * R[i] + beta * (mean(R) - R[i])
  }

  return(list(dR))
}
```

We also model the observation process. Indeed, the faeces collected during sampling are only those of a number `n_chick_samp` of chickens in the farm.

```{r}
n_chick_samp = 50
obs_process_mod2=function(R, n_chick_samp){
  
  # We cannot sample more chickens than there is on the farm:
  n_chick_samp_farm = min(n_chick_samp, length(R))
  
  chick_samp = sample(1:length(R), n_chick_samp_farm)
  
  return(R[chick_samp])
}
```

### Relationship between the proportion of resistant colonies and the prevalence in chickens

It can be useful to know what is the prevalence of chickens carrying resistance. It means we have to define what a "R" chicken is. More exactly we have to define what proportion `thresh` of a chicken's flora has to be resistant, to call a chicken "R".

$ \forall i \in [1;N_{chi}]$,	if $R_i > thresh$, $i$ is defined as a "R" chicken.

We therefore investigate the relationship between the proportion of resistant bacteria in a set of chickens $R_j$, and the proportion of "R" chickens $R_{chick}$.

We define the ratio $Q$ as:

$$ Q = \frac{R_{chick}}{\overline{R_j}} $$
If $Q \approx 1$, it means the proportion of resistant colonies is a good proxy of the prevalence of resistance in chickens.

We define the function:

```{r}
propcol_prev_rat = function(R, thresh){
  prev = sum(R > thresh)/length(R)
  
  ratio = prev/(mean(R) + 0.00001)
  
  return(ratio)
}

```

Let us suppose the proportion of resistant bacteria ($R_i$) in the set of chickens is drawn in a Gaussian of mean `mean_Ri` and SD 0.05.

We plot the value of $Q$ depending of the values of `mean_Ri` and `thresh`. Note that, for illustration conveniency, all values >2 are set to 2.

```{r}
val_thresh = seq(0, 1, 0.01)
val_mean_Ri = seq(0.1, 0.9, 0.01)

val_tab = as.data.frame(matrix(NA, length(val_thresh)*length(val_mean_Ri), 3))
colnames(val_tab) = c("val_thresh", "val_mean_Ri", "val_ratio")

iter = 0
for (i in val_thresh){
  for (j in val_mean_Ri){
    iter = iter + 1
    
    val_tab$val_thresh[iter] = i
    val_tab$val_mean_Ri[iter] = j
    
    R_test = -1
    count_while = 0
    while(((any(R_test < 0))|(any(R_test > 1))) & (count_while <= 1000)){
      count_while = count_while + 1
      if(count_while == 1000){print("Impossible to have a vector of Ri between 0 and 1 with this value of mean")}
      
      R_test = rnorm(100, j, 0.05)
    }
    
    if(count_while < 1000){
      val_tab$val_ratio[iter] = propcol_prev_rat(R_test, i)
    }
  }
}
val_tab$val_ratio[which(val_tab$val_ratio > 2)] = 2
rm(i, j, iter, count_while, R_test, val_thresh, val_mean_Ri)

p = ggplot(data = val_tab, aes(x=val_thresh, y=val_mean_Ri))
p = p + ggtitle("[Prevalence in chickens] / [Proportion of resistant colonies in the pooled sample]")
p = p + ylab("Mean of Ri") + xlab("Positivity threshold for considering a chicken carries resistance")
p = p + geom_tile(aes(fill = val_ratio))
p + scale_fill_gradient2("Ratio Q", low = rgb(1,0,0), mid = rgb(1,1,1), high = rgb(0,0,1), midpoint = 1, na.value = rgb(0,0,0))


```

We can observe that the value of Q is highly dependant on the distribution of the set of chicken microbiota $R_j$, and on the threshold value.

### Model 2bis: Metapopulation of chicken intestinal microbiotes with environment

What is added to Model 2 is $R_e(t)$, which is the proportion of resistant bacteria in the environment of the farm. We consider the transmission of bacteria between chickens only occurs through the environment.

$$\begin{align*}
  \forall i \in [1;N_{chi}],	\frac{dR_i}{dt} &= 1-(1 + A.\alpha ^ {E(t)}).R_i(t) + \beta_1.(R_e(t)-R_i(t))\\
  \frac{dR_e}{dt} &= \beta_2.(\overline{R_j(t)}-R_e(t))
\end{align*}$$

$\beta_1$ and $\beta_2$ (>0) represent the transmission of resistant bacteria from environment to chicken guts, and from chicken guts to environment, respectively. The other parameters are the same than in Model 2.

<!-- ## Comparison of models 1 and 2: does model 2 add something ? -->

<!-- Models 1 and 2 are similar because they both model a proportion of resistant bacteria. -->

<!-- * In model 1, we model the proportion of resistant bacteria in the global population of bacteria on farm (not considering the internal dynamics of a given farm) -->
<!-- * In model 2, we model the interaction between chickens' gut flora: it's a metapopulation of bacteria -->

<!-- We want to compare the value of $R$ as defined in model 1, and the mean value of $R_i$ as defined in model 2, with a same range of parameters. -->

## Model 3: "R" and "S" chicken individuals (stochastic)

In this model, we consider a given chicken can be either R (carries resistant bacteria) or S (does not carry resistant bacteria). In a given farm f, we consider the variables $R(t)$ representing the number of R chickens and $S(t)$ the number of S chickens.

$N_{chi} = S(t) + R(t)$ is the number of chickens in farm f.

We also introduce $R_e(t)$ the proportion of resistant bacteria in the pooled faeces sample collected in farm f at time t. Note there is a stochastic process during the sample of chickens whose samples are collected.

$$\begin{align*}
  \frac{dR}{dt} &= \beta.\alpha^{E(t)}.S(t).\frac{R(t)}{S(t)+R(t)} - \gamma.R(t) - \nu.R(t)\\
  \frac{dS}{dt} &= -\beta.\alpha^{E(t)}.S(t).\frac{R(t)}{S(t)+R(t)} + \gamma.R(t)  - \nu.S(t)\\
  R_e(t) &= p_R.\frac{R_{sample}(t)}{S_{sample}(t)+R_{sample}(t)} + p_S.\frac{S_{sample}(t)}{S_{sample}(t)+R_{sample}(t)} = p_R.r_{sample}(t) + p_S.s_{sample}(t)
\end{align*}$$

where:

* $p_R$ is the proportion of gut bacteria of a "R" chicken that are resistant
* $p_S$ is the proportion of gut bacteria of a "S" chicken that are resistant
* $E(t)$ is AMU (0 or 1) on farm, at week t
* $S_{sample}$ is the number of "S" chickens whose faeces were collected
* $R_{sample}$ is the number of "R" chickens whose faeces were collected
* $\beta$ represents the transmission rate of resistant bacteria from "R" chickens to "S" chickens
* $\gamma$ represents the clearance rate of resistant bacteria from "R" chickens
* $\alpha$ represents the effect of AMU on colistin resistance dynamics:
  * If $\alpha = 1$, AMU has no effect on colistin resistance.
  * If $\alpha < 1$, AMU decreases resistance transmission rate between chickens.
  * If $\alpha > 1$, AMU increases resistance transmission rate between chickens.
* $\nu$ represents the weekly mortality rate in chickens

We also model the observation process. Indeed, the faeces collected during sampling are only those of a number `n_chick_samp` of chickens in the farm.

```{r}
n_chick_samp = 50
obs_process_mod3=function(state, param){
  S = state[1]
  R = state[2]
  
  # We cannot sample more chickens than there is on the farm:
  n_chick_samp = min(param[[1]], S+R)
  
  pS = param[[2]] # Proportion of resistant bacteria in "S" chickens
  pR = param[[3]] # Proportion of resistant bacteria in "R" chickens
  
  n_samp_R = sum(sample(c(rep(1, R), rep(0, S)), n_chick_samp, replace=F)) # Number of "R" individuals whose feces are collected
  n_samp_S = n_chick_samp - n_samp_R # Number of "S" individuals whose feces are collected
  
  # Re: Proportion of resistant bacteria in the pooled sample collected
  Re = pS * n_samp_S/(n_samp_S + n_samp_R) + pR * n_samp_R/(n_samp_S + n_samp_R)
  
  return(Re)
}
```

### Testing the observation process in Model 3

We investigate the relationship between the proportion of "R" individual chickens $\frac{R(t)}{S(t)+R(t)}$ (i.e. chickens carrying resistant bacteria, as opposed to "S" chickens) in the farm, and the proportion of resistant colonies $R_e(t)$.

We define the ratio $Q$ as:

$$ Q = \frac{\frac{R}{S+R}}{R_e} $$
If $Q \approx 1$, it means the proportion of resistant colonies is a good proxy of the prevalence of resistance in chickens.

We define a function *plot_Q* for plotting the mean value of $Q$ (out of 100 simulations) depending on $p_R$ and $p_S$.

```{r}
plot_Q = function(S_farm, R_farm, val_pS=seq(0,1,0.05), val_pR=seq(0,1,0.05), n_chick_samp=50){

  sens_an = as.data.frame(matrix(NA, length(val_pS)*length(val_pR), 3))
  colnames(sens_an) = c("val_pS", "val_pR", "val_proxy")
  sens_an$val_pS = rep(val_pS, length(val_pR))
  sens_an$val_pR = as.vector(matrix(rep(val_pR, length(val_pS)), length(val_pS), length(val_pR), byrow=T))
  
  for(pS in val_pS){
    for(pR in val_pR[which(val_pR >= pS)]){
      Q_rat = c()
      for (iter in 1:100){
        Q_rat = c(Q_rat, obs_process_mod3(c(S_farm, R_farm), list(n_chick_samp, pS, pR)))
      }
      sens_an$val_proxy[which((sens_an$val_pS == pS) & (sens_an$val_pR == pR))] = (R_farm /(S_farm + R_farm))/mean(Q_rat)
    }
  }
  sens_an$val_proxy[which(sens_an$val_proxy > 2)] = 2
  
  p = ggplot(data = sens_an, aes(x=val_pS, y=val_pR))
  p = p + ggtitle(paste0("Value of Q with S=",S_farm," and R=",R_farm))
  p = p + xlab("pS")
  p = p + ylab("pR")
  p = p + geom_tile(aes(fill = val_proxy))
  p = p + scale_fill_gradient2("Q", low = rgb(1,0,0), mid = rgb(1,1,1), high = rgb(0,0,1), midpoint = 1, na.value = rgb(0,0,0))
  p
  
  return(p)
}
```
*Note*: The value of $Q$ is limited to 2 for illustration efficiency.

#### Impact of $p_R$ and $p_S$ on the value of $Q$

By definition, $p_R$ and $p_S$ affect $Q$.

For instance, if $R_{farm} = 60$ and $S_{farm} = 40$:

```{r}
plot_Q(S_farm=40, R_farm= 60)
```

#### Mean value of $Q$ depending on the prevalence of resistance

Here, we consider a fixed farm size of 100 chickens.

We investigate how the mean value of $Q$ changes with the proportion of "R" chickens (20%, 50% and 80%).

```{r}
p1 = plot_Q(S_farm=80, R_farm=20)
p2 = plot_Q(S_farm=50, R_farm=50)
p3 = plot_Q(S_farm=20, R_farm=80)

multiplot(p1,p2,p3, cols=2)
rm(p1, p2, p3)
```

The only values of $p_R$ and $p_S$ that ensure a value of $Q \approx 1$ no matters the prevalence are $p_R = 1$ and $p_S = 0$ (which makes sense).

#### Variability of $Q$ depending on the farm size

We define a function *plot_sd_Q* that is similar to *plot_Q* excepted it plots the Standard Deviation of Q.

```{r}
plot_sd_Q = function(S_farm, R_farm, val_pS=seq(0,1,0.05), val_pR=seq(0,1,0.05), n_chick_samp=50){

  sens_an = as.data.frame(matrix(NA, length(val_pS)*length(val_pR), 3))
  colnames(sens_an) = c("val_pS", "val_pR", "val_proxy")
  sens_an$val_pS = rep(val_pS, length(val_pR))
  sens_an$val_pR = as.vector(matrix(rep(val_pR, length(val_pS)), length(val_pS), length(val_pR), byrow=T))
  
  for(pS in val_pS){
    for(pR in val_pR[which(val_pR >= pS)]){
      Q_rat = c()
      for (iter in 1:100){
        Q_rat = c(Q_rat, obs_process_mod3(c(S_farm, R_farm), list(n_chick_samp, pS, pR)))
      }
      sens_an$val_proxy[which((sens_an$val_pS == pS) & (sens_an$val_pR == pR))] = sd(Q_rat)
    }
  }

  p = ggplot(data = sens_an, aes(x=val_pS, y=val_pR))
  p = p + ggtitle(paste0("SD of Q with S=",S_farm," and R=",R_farm))
  p = p + xlab("pS")
  p = p + ylab("pR")
  p = p + geom_tile(aes(fill = val_proxy))
  p = p + scale_fill_gradient2("Q sd", low = rgb(1,1,1), mid = rgb(1,1,0.5), midpoint = 0.03, na.value = rgb(0,0,0))
  p
  
  return(p)
}
```

With a same prevalence of 60%, we test several farm sizes: 100, 1000, 10000.

```{r}
p1 = plot_sd_Q(S_farm=40, R_farm=60)
p2 = plot_sd_Q(S_farm=400, R_farm=600)
p3 = plot_sd_Q(S_farm=4000, R_farm=6000)

multiplot(p1,p2,p3,cols=2)
rm(p1, p2, p3)
```

The variability of $Q$ seems to increase with the farm size, which makes sense regarding the fixed sample size (`n_chick_samp = 50`)

### Implementation of Model 3

```{r}

mod_transitions <- list(
  c(S = -1, R = 1), # infection by resistant bacteria
  c(R = -1, S = 1), # recovery from resistant bacteria
  c(S = -1, R = 0), # death of "S" individuals
  c(R = -1, S = 0) # death of "R" individuals
)

mod_rateFunc <- function(state, parameters, t) {
  
  beta <- parameters[[1]]
  gamma <- parameters[[2]]
  alpha <- parameters[[3]]
  nu <- parameters[[4]]
  ab_expo_f <- parameters[[5]]
  
  S <- state["S"]
  R <- state["R"]
  N <- S + R
  
  t_day = max(ceiling(t), 1)
  
  return(c(
    (alpha ^ ab_expo_f[t_day]) * beta * S * R / max(N,1),
    gamma * R,
    nu * S,
    nu * R
  ))
}

pred_mod_3 = function(farm, param){
  beta = param[[1]]
  gamma = param[[2]]
  alpha = param[[3]]
  nu = 0 #param[[4]]
  eta = param[[5]]
  pS = param[[6]] # Proportion of resistant bacteria in "S" chickens
  pR = param[[7]] # Proportion of resistant bacteria in "R" chickens
  
  n_weeks_farm = sum(!(is.na(ab_expo[farm,])))
  n_samp_farm = sum(!(is.na(weeks_samp[farm,])))
  if(n_samp_farm < 2){print(paste0("CAUTION: For farm ", farm,", the number of samples collected is strictly less than 2"))}

  ab_expo_farm = ab_expo[farm,]
  init_prev = round(eta*init_flock_size[farm])

  pred_ev = data.frame(ssa.adaptivetau(init.values = c(S = as.numeric(init_flock_size[farm]-init_prev), R = as.numeric(init_prev)), transitions = mod_transitions, rateFunc = mod_rateFunc, params = list(beta, gamma, alpha, nu, ab_expo_farm), tf = n_weeks_farm))
  
  pred_S = approx(x = pred_ev$time, y = pred_ev$S, xout = 1:n_weeks_farm, method = "constant")
  pred_R = approx(x = pred_ev$time, y = pred_ev$R, xout = 1:n_weeks_farm, method = "constant")

  # Number of chickens in the farm:
  pred_numb_chi = pred_S$y + pred_R$y
  
  # Observation process:
  pred_count = rep(NA, n_samp)
  for (w in 1:n_samp_farm){
    pred_count[w] = obs_process_mod3(c(pred_S$y[weeks_samp[farm,w]], pred_R$y[weeks_samp[farm,w]]), list(50, pS, pR))
  }

  return(list(pred_numb_chi, pred_count))
}
```

We define a function convenient for parameters estimation:

```{r}
# param_rand = list(0.2, 0.3, 1.1, 0.026, 0.8, 0.2, 0.8)

run_mod3 = function(param){
  
  pred_numb_chi = matrix(NA, n_cyc, n_weeks)
  pred_sampl_dates = matrix(NA, n_cyc, n_samp)
  
  for (farm in 1:n_cyc){
    nsimu=10
    pred_numb_chi_this_farm = matrix(NA, nsimu, n_weeks)
    pred_sampl_dates_this_farm = matrix(NA, nsimu, n_samp)
    for(s in 1:nsimu){
      pred_this_farm_this_simu = pred_mod_3(farm,as.list(param))
      
      pred_numb_chi_this_farm[s,] = c(pred_this_farm_this_simu[[1]], rep(NA, length(pred_numb_chi_this_farm[s,]) - length(pred_this_farm_this_simu[[1]])))
      
      pred_sampl_dates_this_farm[s,] = pred_this_farm_this_simu[[2]]
    }
    pred_numb_chi[farm,] = colMeans(pred_numb_chi_this_farm, na.rm=T)
    pred_sampl_dates[farm,] = colMeans(pred_sampl_dates_this_farm, na.rm=T)
  }

  # to_min_numb_chi = sum((pred_numb_chi-[vecteur avec tailles population observees a chaque semaine])^2, na.rm=T)
  to_min_sampl_dates = sum((pred_sampl_dates-obs)^2, na.rm=T)

  return(to_min_sampl_dates)
  # return(list(to_min, pred_sampl_dates))
}

```

We use "optim" function for point estimates:

```{r}
fit = optim(par=c(1, 1, 1, 0.01, 1, 0.2, 0.8), fn=run_mod3, lower=rep(0,7), upper=c(5,5,5,1,1,1))
print(fit$par)
```


### Evolution of variability with flock size

In this stochastic model, the variability of the outcome is susceptible to vary with the flock size in two ways:

* If the flock size increases, the variability due to the stochasticity of the model (biological stochasticity) will decrease

* If the flock size increases, the variability due to the observation process (sampling of a constant number of chickens, no matters the flock size) will increase

We create a function that gives the SD of the model's predictions (mean of the different samples), depending on the farm size. (It is based on farm 3 for which we artificially modify flock size.)

```{r}
var_f_size = function(flock_size = as.numeric(init_flock_size[3])){
  
  beta_rand = 0.3
  gamma_rand = 0.4
  alpha_rand = 1.1
  nu_rand = 0.026
  eta_rand = 0.5
  pS_rand = 0.1
  pR_rand = 0.9
  
  n_weeks_farm = sum(!(is.na(ab_expo[3,])))
  n_samp_farm = sum(!(is.na(weeks_samp[3,])))
    
  ab_expo_farm = ab_expo[3,]
  init_prev = round(eta_rand*flock_size)

  pred_simu = matrix(NA, 10000, n_samp)
  for (simu in 1:10000){
    pred_ev = data.frame(ssa.adaptivetau(init.values = c(S = as.numeric(flock_size-init_prev), R = as.numeric(init_prev)), transitions = mod_transitions, rateFunc = mod_rateFunc, params = list(beta_rand, gamma_rand, alpha_rand, nu_rand, ab_expo_farm), tf = n_weeks_farm))
    
    pred_S = approx(x = pred_ev$time, y = pred_ev$S, xout = 1:n_weeks_farm, method = "constant")
    pred_R = approx(x = pred_ev$time, y = pred_ev$R, xout = 1:n_weeks_farm, method = "constant")
    
    # Observation process:
    pred_count = rep(NA, n_samp)
    for (w in 1:n_samp_farm){
      pred_count[w] = obs_process_mod3(c(pred_S$y[weeks_samp[3,w]], pred_R$y[weeks_samp[3,w]]), list(50, pS_rand, pR_rand))
    }
      
    pred_simu[simu,] = pred_count
  }
  
  return(mean(apply(X=pred_simu, MARGIN=2, FUN=sd, na.rm=T)))
}
```

We plot the evolution of SD with the flock size:

```{r, cache=T}
val_flock_size = c(50, 100, 300, 500, 1000, 2000, 5000)
evo_sd = as.data.frame(matrix(c(val_flock_size, rep(NA, length(val_flock_size))), length(val_flock_size), 2))
colnames(evo_sd) = c("flocksize", "sd")

for (i in 1:nrow(evo_sd)){
  print(paste0(i,"/",nrow(evo_sd)))
  evo_sd$sd[i] = var_f_size(evo_sd$flocksize[i])
}
rm(i, val_flock_size)

plot(x=evo_sd$flocksize, y=evo_sd$sd, ylim=c(0,max(evo_sd$sd)), type="l", xlab="Flock size", ylab="SD")
```

